# Rust Sound Synthesis Profiling Dummy Project

The goal of this repository is to play as many sine waves as possible with as little DSP load as possible in order to maximise DSP performance.

## Method

Play 400 sine waves. Record the "DSP load" meter presented through QjackCtl and whether there are any xruns or not.

JACK settings for the results below: 48kHz, 256 frames/buffer, 3 periods

Comparing exact percentages is probably only possible on the same machine and they can vary with what other processes are running at the same time so take them with a pinch of salt.

## Results so far


I tried a few different implementations of playing sine tones:

| Implementation                          |           DSP% |
|:----------------------------------------|---------------:|
| shared_wavetable_synth                  |         27-31% |
| oscen_synth                             |  runaway xruns/no sound |
| owned_wavetable_synth                   |            48% |
| dasp_synth (no wavetable)               | 35% with xruns |

After this I decided to focus on the shared_wavetable_synth

| Implementation | DSP% |
|:----------------------------------------|---------------:|
| baseline (no DSP, only the loop)        |           1.1% (indistinguishable from idle) |
| DSP, but no copying to the frame buffer |          15.1% |
| remove interpolation |          17.6% |
| remove boxing        |          16.5% |
| remove boxing and Option around Wavetables   |    17.1% |
| put the phase inside of Oscillator | 14% |
| Replace f64 modulo by while loop | 6.8% |


Trying to get the CPU usage of the shared_resources_synth implementation down.

- Changing from f64 to f32 = no improvement
- Changing from linear interpolation of wavetable samples to no interpolations: 34% improvement
- Changing the size of the wavetable: no improvement
- Enabling lto in the release profile: slightly worse performance
- Not `Box`ing the `Oscillator`s: small improvement
- Not putting `Wavetable`s inside an `Option` and matching in `Oscillator`: slightly worse performance (why?)
- Not using the Phase class and instead handling that in the Oscillator class: 15% improvement
- Using a while loop to contain the phase within 0<= phase < 1 instead of `% 1.0`: 51% improvement
- Indexing into the wavetable with an unsafe `get_unchecked`: 9% improvement
- Replacing the Wavetable buffer Vec with an array or a boxed array: no improvement

## Calculating phase

Here's a separate experiment where I only change the way that the phase is calculated (the measurements are with the same pitch but random initial phase).

First the method used by the code generated by Faust, 15.8% DSP load

```rust
let temp_phase = self.phase;
self.phase = self.phase + self.step - (self.phase + self.step).floor();
```


Second, using a conditional in a loop, 11.4% DSP load
```rust
let temp_phase = self.phase;
self.phase += self.step;
while self.phase >= 1.0 {
    self.phase -= 1.0;
}
```

And lastly, using the modulo operator, 21.5% DSP load
```rust
let temp_phase = self.phase;
self.phase = (self.phase + self.step) % 1.0;
```


Personally, I was surprised that what looks like branching code with a conditional jump was faster than the non-branching versions and that the modulo operator is so very slow (comparably).


## Comparison with SuperCollider

Running the following code in SuperCollider gives a DSP load of ~4.7%

```supercollider
(var numOscillators = 400, amp = 1.0/numOscillators;
{
	var sig = DC.ar(0);
	numOscillators.do {
		sig = sig + SinOsc.ar(200.0, mul: amp);
	};
	sig
}.play;
)
```

Of course, SuperCollider has seen decades of optimisations so I think its performance is a good target to strive for eventually.

## Comparison with Faust generated Rust

```faust
import("stdfaust.lib");
freq = 200;
nOscillators = 400;
amp = 1.0/nOscillators;
process = sum(i,nOscillators,os.osc(freq) * amp) <: _,_;
```

The Faust compiler can transpile this to Rust using the jack crate version 0.5.3 with a DSP load of just 2%. How does it manage to be so efficient? The following is the main compute function:

```rust
pub fn compute(&mut self, count: i32, inputs: &[&[f32]], outputs: &mut[&mut[f32]]) {
    for i in 0..count {
        self.fRec1[0] = (self.fConst0 + (self.fRec1[1] - f32::floor((self.fConst0 + self.fRec1[1]))));
        let mut fTemp0: f32 = (1.0 * unsafe { ftbl0mydspSIG0[((65536.0 * self.fRec1[0]) as i32) as usize] });
        outputs[0][i as usize] = (fTemp0 as f32);
        outputs[1][i as usize] = (fTemp0 as f32);
        self.fRec1[1] = self.fRec1[0];
    }
}
```

Let's take it apart. 

`fRec1` is a `[f32;2]`. `fConst0` is a constant with the value `self.fConst0 = (200.0 / f32::min(192000.0, f32::max(1.0, (self.fSampleRate as f32))));`, i.e. the step size of the phase for each sample. Line 3 would therefore read the old phase from `fRec1[1]`, add the step size to it and subtract 1 if the phase would be >= 1.0.

`ftbl0mydspSIG0` is a wavetable containing a sine wave with a resolution of 65536 samples which the phase is indexing into.

The Faust compiler has therefore cleverly optimised away all of the equal frequency sine waves into just one single sine wave with an amplitude of 1.0. Making the freq different for each one allowed us to see the performance of actually having all of the sine waves:

```faust
import("stdfaust.lib");
freq = 200;
nOscillators = 400;
amp = 1.0/nOscillators;
process = sum(i,nOscillators,os.osc(freq + i) * amp) <: _,_;
```

This version ran with a DSP load of 12.8% and does the exact same thing as the previous code, only 400 times with different frequencies. To be fair I tested SuperCollider and the current shared_wavetable_synth version against this benchmark:

| Implementation with freq = 200+n | DSP% |
|:-- | --: |
| Faust -> rust/jack | 12.8% |
| shared_wavetable_synth | 12.3% |
| SuperCollider | 5.3% |

SuperCollider is clearly doing something clever that the two Rust implementations do not.

### Speculations as to why SuperCollider is so fast and having different frequencies increases load

(N.B. I am no expert on these low level hardware and optimisation topics. The following might be completely wrong)

One difference between having one pitch and several is that with just one pitch all of the oscillators will index into the same slice of the wavetable, wheras if the pitches are different the phases will not be in sync and will have to acces different parts of the wavetable. Maybe there is a caching benefit to accessing the same sample repeatedly vs random ones. The following experiment strengthens my suspicions of this as the load is the same with random start phase as with different pitches.

| Implementation  | DSP% |
|:-- | --: |
| same pitch, same phase | 7.1% |
| same pitch, random start phase | 11.5% |
| different pitch, random start phase | 11.4% |
| differen pitch, same start phase | 11.4% | 

In the last test case (different pitch, same start phase) the sine waves go in and out of phase with eachother and the DSP load also seems to vary much more which fits the hypothesis. Similar differences occur in SuperCollider, although on a smaller scale.

What I know SuperCollider does that none of the Rust implementations do is using a real time allocator and locking the memory it's using meaning it cannot be paged (https://linux.die.net/man/2/mlock). I don't think paging should be an issue though as there is no shortage of RAM.

## Acknowledgements

The main loop is adapted from examples from the jack crate.